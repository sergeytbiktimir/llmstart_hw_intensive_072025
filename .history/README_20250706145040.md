# LLM Telegram-ассистент (MVP)

## Описание
Минимальный Telegram-бот для консультаций. Приветствует пользователя и собирает контактные данные. Все секреты — только через .env.

## Быстрый старт
1. Скопируйте `.env.example` в `.env` и укажите свой токен Telegram-бота.
2. Установите зависимости: `conda env create -f environment.yml`
3. Активируйте окружение: `conda activate llm-tg-bot`
4. Запустите бота: `python src/bot.py`

## Пример .env
```
TELEGRAM_BOT_TOKEN=your-telegram-bot-token-here
```

## Структура проекта
- src/ — исходный код бота
- tests/ — тесты
- .env.example — пример переменных окружения
- environment.yml — зависимости
- README.md — инструкция

## Требования
- Все секреты только в .env (python-dotenv)
- Оформление кода по PEP8, snake_case, 2 пробела
- Покрытие тестами не менее 99% для ключевых модулей 

## Смена типа хранилища (БД)

По умолчанию используется SQLite (файл data/contacts.db) через класс `SQLiteStorage`.

Чтобы заменить тип хранилища (например, на файловое или внешнюю БД):
1. Реализуйте свой класс-наследник от `Storage` в `src/storage.py`.
2. В файле `src/storage.py` создайте экземпляр вашего класса вместо `SQLiteStorage`:
   ```python
   # storage = SQLiteStorage()  # по умолчанию
   storage = MyCustomStorage(...)
   ```
3. Весь код бота использует только экземпляр `storage` — менять остальной код не требуется.

Чтобы изменить путь к базе данных SQLite:
- Передайте путь при создании экземпляра:
  ```python
  storage = SQLiteStorage(db_path='data/my_db.db')
  ``` 

## Использование внешней БД (PostgreSQL, MySQL, MongoDB и др.)

1. Реализуйте класс-наследник от `Storage` (см. `src/storage.py`) для вашей СУБД.
2. Все параметры подключения храните в `.env`. Примеры:
   - PostgreSQL:
     ```
     POSTGRES_DSN=postgresql://user:password@host:port/dbname
     ```
   - MySQL:
     ```
     MYSQL_DSN=mysql://user:password@host:port/dbname
     ```
   - MongoDB:
     ```
     MONGO_URI=mongodb://user:password@host:port/dbname
     ```
3. В `src/storage.py` создайте экземпляр вашего класса:
   - PostgreSQL (psycopg2):
     ```python
     import os
     import psycopg2
     from storage import Storage
     class PostgresStorage(Storage):
         def __init__(self, dsn):
             self.conn = psycopg2.connect(dsn)
         def save_contact(self, user_id, name, contact):
             with self.conn, self.conn.cursor() as c:
                 c.execute('INSERT INTO contacts (user_id, name, contact, created_at) VALUES (%s, %s, %s, NOW())', (user_id, name, contact))
         def save_history(self, user_id, action, details=""):
             with self.conn, self.conn.cursor() as c:
                 c.execute('INSERT INTO history (user_id, action, details, created_at) VALUES (%s, %s, %s, NOW())', (user_id, action, details))
     # storage = PostgresStorage(os.environ["POSTGRES_DSN"])
     ```
   - MySQL (pymysql):
     ```python
     import os
     import pymysql
     from storage import Storage
     class MySQLStorage(Storage):
         def __init__(self, dsn):
             self.conn = pymysql.connect(dsn)
         def save_contact(self, user_id, name, contact):
             with self.conn.cursor() as c:
                 c.execute('INSERT INTO contacts (user_id, name, contact, created_at) VALUES (%s, %s, %s, NOW())', (user_id, name, contact))
             self.conn.commit()
         def save_history(self, user_id, action, details=""):
             with self.conn.cursor() as c:
                 c.execute('INSERT INTO history (user_id, action, details, created_at) VALUES (%s, %s, %s, NOW())', (user_id, action, details))
             self.conn.commit()
     # storage = MySQLStorage(os.environ["MYSQL_DSN"])
     ```
   - MongoDB (pymongo):
     ```python
     import os
     import pymongo
     from storage import Storage
     class MongoStorage(Storage):
         def __init__(self, uri):
             self.client = pymongo.MongoClient(uri)
             self.db = self.client.get_default_database()
         def save_contact(self, user_id, name, contact):
             self.db.contacts.insert_one({"user_id": user_id, "name": name, "contact": contact, "created_at": datetime.utcnow()})
         def save_history(self, user_id, action, details=""):
             self.db.history.insert_one({"user_id": user_id, "action": action, "details": details, "created_at": datetime.utcnow()})
     # storage = MongoStorage(os.environ["MONGO_URI"])
     ```
4. Весь остальной код менять не требуется — используйте только экземпляр `storage`. 

## Каталог услуг: структура и смена источника

Каталог услуг реализован через абстракцию `ServiceCatalog` и может храниться в разных источниках:
- JSON-файл (по умолчанию, src/services_catalog.json)
- БД (таблица services)
- (В перспективе) облачные сервисы

### Формат услуги
```json
{
  "id": 1,
  "name": "Название услуги",
  "description": "Описание услуги"
}
```

### Пример файла src/services_catalog.json
```
[
  {
    "id": 1,
    "name": "Консультация по LLM",
    "description": "Персональная консультация по внедрению и использованию LLM в бизнесе."
  },
  {
    "id": 2,
    "name": "Анализ бизнес-процессов",
    "description": "Экспертный анализ процессов компании для поиска точек автоматизации."
  }
]
```

### Смена источника каталога

- По умолчанию используется файл:
  ```python
  from service_catalog import FileServiceCatalog
  service_catalog = FileServiceCatalog()
  ```
- Для использования БД (таблица services: id, name, description):
  ```python
  from service_catalog import DBServiceCatalog
  service_catalog = DBServiceCatalog()
  ```
- Для добавления облачного или другого источника реализуйте свой класс-наследник от ServiceCatalog.

Весь код бота использует только экземпляр `service_catalog` — менять остальной код не требуется. 