# LLM Telegram-ассистент (MVP)

## Описание
Минимальный Telegram-бот для консультаций. Приветствует пользователя и собирает контактные данные. Все секреты — только через .env.

## Быстрый старт
1. Скопируйте `.env.example` в `.env` и укажите свой токен Telegram-бота.
2. Установите зависимости: `conda env create -f environment.yml`
3. Активируйте окружение: `conda activate llm-tg-bot`
4. Запустите бота: `python src/bot.py`

## Пример .env
```
TELEGRAM_BOT_TOKEN=your-telegram-bot-token-here
```

## Структура проекта
- src/ — исходный код бота
- tests/ — тесты
- .env.example — пример переменных окружения
- environment.yml — зависимости
- README.md — инструкция

## Требования
- Все секреты только в .env (python-dotenv)
- Оформление кода по PEP8, snake_case, 2 пробела
- Покрытие тестами не менее 99% для ключевых модулей 

## Смена типа хранилища (БД)

По умолчанию используется SQLite (файл data/contacts.db) через класс `SQLiteStorage`.

Чтобы заменить тип хранилища (например, на файловое или внешнюю БД):
1. Реализуйте свой класс-наследник от `Storage` в `src/storage.py`.
2. В файле `src/storage.py` создайте экземпляр вашего класса вместо `SQLiteStorage`:
   ```python
   # storage = SQLiteStorage()  # по умолчанию
   storage = MyCustomStorage(...)
   ```
3. Весь код бота использует только экземпляр `storage` — менять остальной код не требуется.

Чтобы изменить путь к базе данных SQLite:
- Передайте путь при создании экземпляра:
  ```python
  storage = SQLiteStorage(db_path='data/my_db.db')
  ``` 

## Использование внешней БД (PostgreSQL, MySQL, MongoDB и др.)

1. Реализуйте класс-наследник от `Storage` (см. `src/storage.py`) для вашей СУБД.
2. Все параметры подключения храните в `.env`. Примеры:
   - PostgreSQL:
     ```
     POSTGRES_DSN=postgresql://user:password@host:port/dbname
     ```
   - MySQL:
     ```
     MYSQL_DSN=mysql://user:password@host:port/dbname
     ```
   - MongoDB:
     ```
     MONGO_URI=mongodb://user:password@host:port/dbname
     ```
3. В `src/storage.py` создайте экземпляр вашего класса:
   - PostgreSQL (psycopg2):
     ```python
     import os
     import psycopg2
     from storage import Storage
     class PostgresStorage(Storage):
         def __init__(self, dsn):
             self.conn = psycopg2.connect(dsn)
         def save_contact(self, user_id, name, contact):
             with self.conn, self.conn.cursor() as c:
                 c.execute('INSERT INTO contacts (user_id, name, contact, created_at) VALUES (%s, %s, %s, NOW())', (user_id, name, contact))
         def save_history(self, user_id, action, details=""):
             with self.conn, self.conn.cursor() as c:
                 c.execute('INSERT INTO history (user_id, action, details, created_at) VALUES (%s, %s, %s, NOW())', (user_id, action, details))
     # storage = PostgresStorage(os.environ["POSTGRES_DSN"])
     ```
   - MySQL (pymysql):
     ```python
     import os
     import pymysql
     from storage import Storage
     class MySQLStorage(Storage):
         def __init__(self, dsn):
             self.conn = pymysql.connect(dsn)
         def save_contact(self, user_id, name, contact):
             with self.conn.cursor() as c:
                 c.execute('INSERT INTO contacts (user_id, name, contact, created_at) VALUES (%s, %s, %s, NOW())', (user_id, name, contact))
             self.conn.commit()
         def save_history(self, user_id, action, details=""):
             with self.conn.cursor() as c:
                 c.execute('INSERT INTO history (user_id, action, details, created_at) VALUES (%s, %s, %s, NOW())', (user_id, action, details))
             self.conn.commit()
     # storage = MySQLStorage(os.environ["MYSQL_DSN"])
     ```
   - MongoDB (pymongo):
     ```python
     import os
     import pymongo
     from storage import Storage
     class MongoStorage(Storage):
         def __init__(self, uri):
             self.client = pymongo.MongoClient(uri)
             self.db = self.client.get_default_database()
         def save_contact(self, user_id, name, contact):
             self.db.contacts.insert_one({"user_id": user_id, "name": name, "contact": contact, "created_at": datetime.utcnow()})
         def save_history(self, user_id, action, details=""):
             self.db.history.insert_one({"user_id": user_id, "action": action, "details": details, "created_at": datetime.utcnow()})
     # storage = MongoStorage(os.environ["MONGO_URI"])
     ```
4. Весь остальной код менять не требуется — используйте только экземпляр `storage`. 

## Каталог услуг: структура и смена источника

Каталог услуг реализован через абстракцию `ServiceCatalog` и может храниться в разных источниках:
- JSON-файл (по умолчанию, src/services_catalog.json)
- БД (таблица services)
- (В перспективе) облачные сервисы

### Формат услуги
```json
{
  "id": 1,
  "name": "Название услуги",
  "description": "Описание услуги"
}
```

### Пример файла src/services_catalog.json
```
[
  {
    "id": 1,
    "name": "Консультация по LLM",
    "description": "Персональная консультация по внедрению и использованию LLM в бизнесе."
  },
  {
    "id": 2,
    "name": "Анализ бизнес-процессов",
    "description": "Экспертный анализ процессов компании для поиска точек автоматизации."
  }
]
```

### Смена источника каталога

- По умолчанию используется файл:
  ```python
  from service_catalog import FileServiceCatalog
  service_catalog = FileServiceCatalog()
  ```
- Для использования БД (таблица services: id, name, description):
  ```python
  from service_catalog import DBServiceCatalog
  service_catalog = DBServiceCatalog()
  ```
- Для добавления облачного или другого источника реализуйте свой класс-наследник от ServiceCatalog.

Весь код бота использует только экземпляр `service_catalog` — менять остальной код не требуется. 

### Примеры реализации ServiceCatalog для других источников

- **PostgreSQL** (psycopg2):
  ```python
  import os
  import psycopg2
  from service_catalog import ServiceCatalog
  class PostgresServiceCatalog(ServiceCatalog):
      def __init__(self, dsn):
          self.conn = psycopg2.connect(dsn)
      def get_services(self):
          with self.conn, self.conn.cursor() as c:
              c.execute('SELECT id, name, description FROM services')
              return [
                  {"id": row[0], "name": row[1], "description": row[2]}
                  for row in c.fetchall()
              ]
  # service_catalog = PostgresServiceCatalog(os.environ["POSTGRES_DSN"])
  ```
  В .env:
  ```
  POSTGRES_DSN=postgresql://user:password@host:port/dbname
  ```

- **MongoDB** (pymongo):
  ```python
  import os
  import pymongo
  from datetime import datetime
  from service_catalog import ServiceCatalog
  class MongoServiceCatalog(ServiceCatalog):
      def __init__(self, uri):
          self.client = pymongo.MongoClient(uri)
          self.db = self.client.get_default_database()
      def get_services(self):
          return list(self.db.services.find({}, {"_id": 0}))
  # service_catalog = MongoServiceCatalog(os.environ["MONGO_URI"])
  ```
  В .env:
  ```
  MONGO_URI=mongodb://user:password@host:port/dbname
  ```

- **Облачное API** (пример):
  ```python
  import requests
  from service_catalog import ServiceCatalog
  class CloudServiceCatalog(ServiceCatalog):
      def __init__(self, api_url, api_key):
          self.api_url = api_url
          self.api_key = api_key
      def get_services(self):
          resp = requests.get(self.api_url, headers={"Authorization": f"Bearer {self.api_key}"})
          resp.raise_for_status()
          return resp.json()
  # service_catalog = CloudServiceCatalog(api_url=os.environ["CATALOG_API_URL"], api_key=os.environ["CATALOG_API_KEY"])
  ```
  В .env:
  ```
  CATALOG_API_URL=https://example.com/api/services
  CATALOG_API_KEY=your-api-key
  ``` 

## Настройка логирования

- Уровень логирования задаётся переменной окружения `LOG_LEVEL` (пример: `LOG_LEVEL=INFO`)
- Возможные значения: `DEBUG`, `INFO`, `WARNING`, `ERROR`
- INFO — только ключевые события (запуск, команды, ошибки, смена состояния)
- DEBUG — подробные сообщения (все сообщения пользователя и ассистента, детали запросов/ответов)
- WARNING/ERROR — ошибки, сбои, подозрительные действия
- Пример для .env:
  ```
  LOG_LEVEL=INFO
  ```
- Рекомендуется использовать ротацию логов или хранение в БД/облаке для предотвращения переполнения диска
- Источник логирования можно сменить, создав нужный экземпляр Logger (см. src/logger.py) 